library(RCurl)
library(XML)

have_tcltk <- TRUE
tryCatch(library(tcltk), error=function(e) have_tcltk <<- FALSE)

.xnat.search.type.nosubject <- c('xnat:subjectData')

.xnat.search.xml.build <- function(xsitype, fields, constraints=NULL) {
  header <- sprintf('<?xml version="1.0" encoding="UTF-8"?>
  <xdat:search allow-diff-columns="0" secure="false"
  brief-description="generated by xnat.R"
  xmlns:xdat="http://nrg.wustl.edu/security"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <xdat:root_element_name>%s</xdat:root_element_name>', xsitype)
  footer <- '\n</xdat:search>'
  
  fields.text <- mapply(function(field, index) {
    sprintf('
<xdat:search_field>
  <xdat:element_name>%s</xdat:element_name>
  <xdat:field_ID>%s</xdat:field_ID>
  <xdat:sequence>%d</xdat:sequence>
</xdat:search_field>',
            xsitype, field, index)
  }, fields, seq(0, length(fields)-1), SIMPLIFY=TRUE, USE.NAMES=FALSE)

  if (! xsitype %in% .xnat.search.type.nosubject) {
    fields.text <- c(fields.text, sprintf('
<xdat:search_field>
  <xdat:element_name>xnat:subjectData</xdat:element_name>
  <xdat:field_ID>SUBJECT_LABEL</xdat:field_ID>
  <xdat:sequence>%s</xdat:sequence>
</xdat:search_field>', length(fields)))
  }
  
  constraint.text <- if (is.null(constraints) || 0 == length(constraints))
    ''
  else {
    constraint.matrix <- array(constraints, dim=c(3,length(constraints)/3))
    c('<xdat:search_where method="OR">',
      mapply(function(field, comparison, value) {
        sprintf('
  <xdat:criteria override_value_formatting="0">
    <xdat:schema_field>%s/%s</xdat:schema_field>
    <xdat:comparison_type>%s</xdat:comparison_type>
    <xdat:value>%s</xdat:value>
  </xdat:criteria>', xsitype, field, comparison, value)
      }, constraint.matrix[1,], constraint.matrix[2,], constraint.matrix[3,]),
      '</xdat:search_where>')
  }
  
  do.call(paste0, as.list(c(header, fields.text, constraint.text, footer)))
}


.csv.from.string <- function(string)
{
  c <- textConnection(string)
  csv <- read.csv(c, header=TRUE, as.is=TRUE)
  close(c)
  
  return(csv)
}

.frame.columns.rename <- function(frame, ...) {
  renames <- list(...)
  to.rename <- colnames(frame) %in% names(renames)
  colnames(frame)[to.rename] <- lapply(colnames(frame)[to.rename],
                                       function(name) renames[[name]])
  frame
}
      

xnat.connection <- function(base_url, username=NULL, password=NULL)
{

    .xnat.call <- function(request, customrequest='GET', data='') {
        if(is.null(jsid))
            stop('not connected')
        reader <- basicTextGatherer()
        header <- basicTextGatherer()
        if(nchar(data) > 0)
            customrequest <- 'POST'
        curlPerform(url=paste(base_url, request, sep=''), 
                    writefunction=reader$update, 
                    headerfunction=header$update, 
                    customrequest=customrequest, 
                    postfields=data, 
                    ssl.verifypeer=FALSE, 
                    cookie=paste('JSESSIONID=', jsid, sep=''))
        if(parseHTTPHeader(header$value())['status'] != 200) {
            stop('error during HTTP request')
        }
        return(reader$value())
      }

    .search.fields.get <- function(xsitype) {
      data <- .xnat.call(sprintf('/data/search/elements/%s?format=csv', xsitype))
      table <- .csv.from.string(data)
      table <- table[,c('FIELD_ID', 'DESC')]
      table <- table[grep('PROJECT_IDENTIFIER=', table$FIELD_ID, invert=TRUE),]
      table <- table[grep('_FIELD_MAP=', table$FIELD_ID, invert=TRUE),]
      ns <- toupper(sub(':\\w+', '', xsitype))
      table <- table[grep(sprintf('^%s_COL_', ns), table$FIELD_ID, invert=TRUE),]
      .frame.columns.rename(table, 'FIELD_ID'='name', 'DESC'='description')
    }

    close <- function() {
        data <- .xnat.call('/data/JSESSION', customrequest='DELETE')
        jsid <<- NULL
    }

    projects <- function() {
        if(is.null(.projects)) {
            data <- .xnat.call('/data/projects?format=csv')
            csv <- .csv.from.string(data)
            csv <- csv[with(csv, order(ID)),]
            rownames(csv) <- 1:nrow(csv)
            .projects <<- csv
        }
        return(.projects)
    }

   # requests without a project constraint are cached;
   # requests with a project constraint do not use the cache because
   # we also want subjects that have been shared into the named project
    subjects <- function(project=NULL) {
      if(!is.null(project) && !project %in% projects()$ID) {
        stop(sprintf('unknown project "%s"', project))
      } 
      if(is.null(.subjects) || !is.null(.projects)) {
        fields <- c('PROJECT','ID','LABEL','GENDER_TEXT','HANDEDNESS_TEXT',
                    'DOB','EDUC','SES','SUB_GROUP','RACE','ETHNICITY')
        if (!is.null(project)) {
          project <- c('PROJECT','=',project, 'sharing/share/project','=',project)
        }
        data <- .xnat.call('/data/search?format=csv',
                           data=.xnat.search.xml.build('xnat:subjectData', fields, project))
        csv <- .csv.from.string(data)

        # we don't want some of the columns; drop these
        csv <- subset(csv, select=-c(subject_id, quarantine_status))

        # some of the columns returned from XNAT are weirdly named; rename these
        csv <- frame.columns.rename(csv,
                                    'subjectid'='ID',
                                    'xnat_col_subjectdatalabel'='label',
                                    'gender_text'='gender',
                                    'handedness_text'='handedness',
                                    'educ'='education',
                                    'sub_group'='group')
        
        csv <- csv[with(csv, order(project, label)),]
        rownames(csv) <- 1:nrow(csv)
        if(is.null(project)) {
          .subjects <<- csv
        } else {
          return(csv)
        }
      }
      return(.subjects)
    }

    # Retrieves list of all searchable types
    .search.types.get <- function() {
      text <- .xnat.call('/data/search/elements?format=csv')
      table <- .csv.from.string(text)
      table <- table[,c('ELEMENT_NAME','SINGULAR')]
      table <- .frame.columns.rename(table, 'ELEMENT_NAME'='type', 'SINGULAR'='name')
    }
      
    .get.experiment.types <- function(project=NULL, subject=NULL) {
        if(is.null(.experiment.types)) {
            # we're getting searchable types here, which may not be complete, 
            # but is better than nothing
            data <- .xnat.call('/data/search/elements?format=csv')
            csv <- .csv.from.string(data)
            et <- grep('^xnat:.*SessionData$', csv$ELEMENT_NAME, value=TRUE)
            if(length(et) == 0) {
                warning('error getting experiment types; falling back on CT, MR, PET, US')
                .experiment.types <<- c('xnat:ctSessionData', 
                                        'xnat:mrSessionData', 
                                        'xnat:petSessionData', 
                                        'xnat:usSessionData')
            } else {
                .experiment.types <<- et
            }
        }
        return(.experiment.types)
      }

    experiments <- function(e_project=NULL, e_subject=NULL) {
        if(is.null(.experiments)) {
            experiments <- NULL
            for(type in .get.experiment.types()) {
              in_data <- .xnat.search.xml.build(type,
                                                c('PROJECT','LABEL','SUBJECT_ID','AGE'))
                out_data <- .xnat.call('/data/search?format=csv', 
                                       data=in_data)
                csv <- .csv.from.string(out_data)
                if(nrow(csv) > 0) {
                    if(type == 'xnat:mrSessionData') {
                        csv <- subset(csv, select=c(subject_id, session_id, label, age))
                    } else {
                        csv <- subset(csv, select = c(subject_id, expt_id, label, age))
                    }
                    names(csv) <- c('subject_id', 'ID', 'label', 'age')
                    csv$type <- rep(type, nrow(csv))
                    experiments <- rbind(experiments, csv)
                }
            }
        }
        if(is.null(experiments)) {
            .experiments <<- data.frame()
        } else {
            ss <- subset(subjects(), select=c(ID, label, project))
            experiments <- merge(experiments, 
                                 ss, 
                                 by.x='subject_id', 
                                 by.y='ID')
            experiments <- subset(experiments, select = c(project, 
                                                          label.y, 
                                                          ID, 
                                                          type, 
                                                          label.x, 
                                                          age))
            names(experiments) <- c('project', 
                                    'subject', 
                                    'ID', 
                                    'type', 
                                    'label', 
                                    'age')
            experiments <- experiments[with(experiments, 
                                            order(project,subject,label)),]
            rownames(experiments) <- 1:nrow(experiments)
            .experiments <<- experiments
        }

        if(!is.null(e_project)) {
            if(!e_project %in% projects()$ID) {
                stop(sprintf('unknown project "%s"', e_project))
            }
            if(!is.null(e_subject)) {
                if(!e_subject %in% subjects(e_project)$label) {
                    stop(sprintf('no subject "%s" in project %s', e_subject, e_project))
                rv <- .experiments[.experiments$project==e_project&&.experiments$subject==e_subject,]
                rownames(rv) <- 1:nrow(rv)
                return(rv)
                }
            rv <- .experiments[.experiments$project==project,]
            rownames(rv) <- 1:nrow(rv)
            return(rv)
            }
        }
        return(.experiments)
    }

    .search.subject.joined.renames <- list('xnat_subjectdata_subject_label'='subject_label',
                                           'xnat_subjectdata_project'='subject_project')
    .search.subject.joined.discards <- c('xnat_subjectdata_subjectid',
					 'xnat_subjectdata_insert_user',
                                         'xnat_subjectdata_insert_date',
					 'xnat_subjectdata_projects')
					 
    .search.type.named <- function(type, project=NULL) {
      if (is.null(type)) {
        return(.experiments.multitype(e_project=project))
      } else {
        if (!is.null(project)) {
          project <- c('PROJECT','=',project, 'sharing/share/project','=',project)
        }
        text <- .xnat.call('/data/search?format=csv',
                           data=.xnat.search.xml.build(type,
                             .search.fields.get(type)$name,
                             project))
        table <- .csv.from.string(text)
        ns <- tolower(sub(':\\w+', '', type))
        nstype <- tolower(sub('\\w+:', '', type))
        subjlabel <- sprintf('xnat_subjectdata_subject_label', ns, nstype)

	table <- do.call(.frame.columns.rename, c(list(table), .search.subject.joined.renames))
	table <- table[,!(colnames(nt) %in% .search.subject.joined.discards)]
      }
    }

    run.stored.search <- function(search_id) {
        if(is.null(.saved.searches)) {
            data <- .xnat.call('/data/search/saved?format=csv')
            csv <- .csv.from.string(data)
            .saved.searches <<- csv$id
        }
        if(!search_id %in% .saved.searches) {
            stop(sprintf('unknown stored search "%s"', search_id))
        }
        data <- .xnat.call(paste('/data/search/saved/', 
                                 search_id, 
                                 '/results?format=csv', 
                                 sep=''))
        csv <- .csv.from.string(data)
        return(csv)
    }

    is.connected <- function() {
        if(is.null(jsid))
            return(FALSE)
        return(TRUE)
    }

    reader <- basicTextGatherer()
    header <- basicTextGatherer()
    if(is.null(username)) {
        curlPerform(url=paste(base_url, '/', sep = ''), 
                    writefunction=reader$update, 
                    headerfunction=header$update, 
                    ssl.verifypeer=FALSE)
        jsid <<- NULL
        for(h in strsplit(header$value(), '\n')[[1]]) {
            if(substring(h, 1, 23) == 'Set-Cookie: JSESSIONID=') {
                jsid <<- strsplit(substring(h, 24), ';')[[1]][[1]]
            }
        }
        if(is.null(jsid)) {
            stop('error starting session')
        }
    } else {
        if(is.null(password)) {
            if(!have_tcltk) {
                stop("can't prompt for password without tcltk")
            }
            tt <- tktoplevel()
            tktitle(tt) <- 'XNAT Password'
            onOK <- function() {
                tkgrab.release(tt)
                tkdestroy(tt)
            }
            lab <- tklabel(tt, text='Password:')
            pwVar <- tclVar()
            pw <- tkentry(tt, textvariable=pwVar, show='*')
            but <- tkbutton(tt, text='OK', command=onOK)
            tkgrid(lab, pw, but)
            tkfocus(tt)
            tkwait.window(tt)
            password <- tclvalue(pwVar)
        }
        curlPerform(url=paste(base_url, '/data/JSESSION', sep=''), 
                    writefunction=reader$update, 
                    headerfunction=header$update, 
                    ssl.verifypeer=FALSE, 
                    userpwd=paste(username, password, sep=':'))
        status <- parseHTTPHeader(header$value())['status']
        if(status == 401) {
            stop('bad username/password')
        } else if(status != 200) {
            stop('error authenticating')
        }
        jsid <<- reader$value()
    }

    .projects <- NULL
    .subjects <- NULL
    .experiment.types <- NULL
    .experiments <- NULL
    .saved.searches <- NULL

    rv <- list(base_url=base_url, 
      close=close, 
      is.connected=is.connected, 
      projects=projects, 
      subjects=subjects, 
      experiments=experiments,
      fields=.search.fields.get,
      types=.search.types.get,
      get=.search.type.named,
      run.stored.search=run.stored.search)

    class(rv) <- 'XNATConnection'

    return(rv)

}

# eof
